#include <stdio.h>
#include <math.h>
#include <R.h>
#include <Rdefines.h>

// Maximum size of ensembles
#define ENSEMBLESIZE 1000

// Maximum value allowed in the sorted vector
#define MAXVALSORT 50000

/* SORT routine :
* Permits to sort the values of INI vector in increasing order
* used in c_INTERANN
*   nval  : Number of value to sort
*   IN    : Values to sort
*   indexORD  : Rank of the sorted values in IN
*/
void SORTORD(int nval, double * IN, int * indexORD)
{
	int i,k,rk_minTemp, RKTEMP[MAXVALSORT];
	double MIN, TEMP[MAXVALSORT];
	//printf("nval=%4d\n",nval);
	// Control of vector size
  if(nval>MAXVALSORT){nval=MAXVALSORT;}
	
  // Initialisation
  for(i=0;i<nval;i++){TEMP[i]=IN[i];RKTEMP[i]=1;}

  for(i=0;i<nval;i++){
		MIN=MAXVALSORT;
		// Find the MIN in the remaining data
		rk_minTemp=i;
        for(k=0;k<nval-i;k++){if(TEMP[k]<MIN){MIN=TEMP[k];rk_minTemp=k;}}
        //printf("[%3d] %7.2f %7.2f %5d ",i,IN[i],MIN,rk_minTemp);
    
        // Store the rank (avoid the problem of identical values)
        for(k=0;k<nval;k++){if((IN[k]==MIN)&(RKTEMP[k]!=0)){*(indexORD+i)=k;RKTEMP[k]=0;break;}}
        //printf("  - %5d\n",*(indexORD+i));        

        // Eliminate the value from the dataset
		for(k=0;k<nval-i;k++){if(k>rk_minTemp){TEMP[k-1]=TEMP[k];}}		
		//printf(" %5d\n",*(indexORD+i));
  }   
}


/* ************** Core subroutine ******************************
* Calculate the CRPS as defined by
* Hersbach, H. Decomposition of the continuous ranked probability score for ensemble prediction systems Weather and Forecasting, 2000, 15, 559-570
*
* nval = length of input vectors (number of values)
* ncol = nb of ensembles
* OBS = vector of observed data (nval x 1)
* PRED = matrix of predictions (nval x ncol)
* W = Weights used to compute the average (nval x 1)
* CRPSMAT = matrix containing the CRPS values for each bin (ncol+1 x 5)
*				CRPSMAT(:,1) = pi (=i/ncol) i=0..ncol
*				CRPSMAT(:,2) = ai (Eq 26,27,29 from Hersbach, 2000)
*				CRPSMAT(:,3) = bi (Eq 26,27,29 from Hersbach, 2000)
*				CRPSMAT(:,4) = gi (Eq 30 from Hersbach, 2000)
*				CRPSMAT(:,5) = oi (Eq 31 from Hersbach, 2000)
*				CRPSMAT(:,6) = Reli_i (Eq 36 from Hersbach, 2000)
*				CRPSMAT(:,7) = CRPSpot_i (Eq 37 from Hersbach, 2000)
*
* CRPSVAL = average values of the CRPS
*				CRPSVAL(1) = CRPS (Eq 28 from Hersbach, 2000)
*				CRPSVAL(2) = Reli (Eq 36 from Hersbach, 2000)
*				CRPSVAL(3) = Resol (-1 * Eq 38 from Hersbach, 2000) => !!! resolution is the opposite than the ones defined by Hersbach to keep the negative orientation of the criteria
*				CRPSVAL(4) = U (Uncertainty, Eq 20 from Hersbach, 2000)
*				CRPSVAL(5) = CRPS potential (when predictions are corrected to get perfect reliability)
*
* RESO = relative resolution defined by Renard et al. (2010)
*
* ERRORFLAG = Check of Equation 34 satisfied (1.0) or not (0.0)
************************************************/

void crps(int * _nval,int * _ncol,
  double * OBS,
  double * PRED, 
  double * W,
  double * CRPSMAT,
  double * CRPSVAL,
  double * RESO,
  double * ERRORFLAG)
{
	int i,j,k,iP[ENSEMBLESIZE],nval,ncol;
	double P[ENSEMBLESIZE],sumW,CRPSpot,pj,U,v,std,mean;	
	double a[ENSEMBLESIZE],b[ENSEMBLESIZE];
    double g[ENSEMBLESIZE],o[ENSEMBLESIZE];
    double r[ENSEMBLESIZE],c[ENSEMBLESIZE];

	// Initialisations
	nval = _nval[0];
	ncol= _ncol[0];
	sumW=0.0;CRPSpot=0.0;U=0.0;
	for(j=0;j<ncol+1;j++){a[j]=0;b[j]=0;g[j]=0;o[j]=0;}
	for(k=0;k<4;k++){CRPSVAL[k]=0.0;}
	ERRORFLAG[0]=0.0;
	ERRORFLAG[1]=0.0;
	
	//printf("\nCRPS calculation with nval=%d ncol=%d\n",nval,ncol);

	// Normalisation of the W's and W[i] = |W[i]| to avoid negative weights
	for(i=0;i<nval;i++){
		if(W[i]<0)	W[i]=-W[i];
		sumW+=W[i];
	}
	if(sumW==0.0) sumW=1.0;

	// Computation of the mean ai and bi 
	for(i=0;i<nval;i++){				
		// Initialise variable to calculate RESO
		mean=0;
		std = 0;

		for(j=0;j<ncol;j++){
			P[j]=PRED[i+j*nval]; // Prediction data
			mean+=P[j]; // Intermediate calculation for the mean
		}
		mean=mean/(double)ncol; // Calculate the mean value of the predicted ensemble
		SORTORD(ncol,P,iP);// Sorting

		// Avoid the case where several values are identical

		//printf("%5d (w=%5.2f): %5.2f <->",i,W[i],OBS[i]);
		//for(j=0;j<ncol;j++) printf("%5.2f ",P[iP[j]]);
		//printf("\n");		

		// Computing the ai and bi (Eq 26)
		for(j=0;j<ncol-1;j++){			
			std += pow(P[j]-mean,2); // Intermediate calculation for the standard deviation

			if(OBS[i]<=P[iP[j]]){b[j+1]+= (P[iP[j+1]]-P[iP[j]]) * W[i]/sumW;}

			if(OBS[i]>=P[iP[j+1]]){a[j+1]+= (P[iP[j+1]]-P[iP[j]]) * W[i]/sumW;}

			if(OBS[i]>P[iP[j]] && OBS[i]<P[iP[j+1]]){
 				a[j+1]+= (OBS[i]-P[iP[j]]) * W[i]/sumW;
 				b[j+1]+= (P[iP[j+1]]-OBS[i]) * W[i]/sumW;
			}
			//printf("(%5.2f,%5.2f) ",a[j+1],b[j+1]);
		} 
		//printf("\n");	

		// Standard deviation of the ensemble and calculation of RESO
		std = pow(std/(double)(ncol-1),0.5);
		if(mean<0) mean=-mean;
		RESO[0]+=W[i]/sumW*mean/std;

		// b0 (Eq 27)
		if(OBS[i]<P[iP[0]]) b[0]+= (P[iP[0]]-OBS[i]) * W[i]/sumW;
		
		// aN (Eq 27)
		if(OBS[i]>=P[iP[ncol-1]]) a[ncol]+= (OBS[i]-P[iP[ncol-1]]) * W[i]/sumW;

		
		if(OBS[i]<P[iP[0]]) o[0] += W[i]/sumW; // o0 (Eq 33)

		
		if(OBS[i]<P[iP[ncol-1]]) o[ncol] += W[i]/sumW; // oN (Eq 33)

		// Computation of uncertainty (Eq 19)
		for(k=0;k<i;k++){	

			v =  OBS[i]-OBS[k];
			if(v<0) v =  OBS[k]-OBS[i];  // ?????????????? abs(OBS[i]-OBS[k]) does not work - bug ?

			U += (W[i]/sumW) * (W[k]/sumW) * v;
			//printf("%d %d %5.2f %5.2f %5.2f %5.2f %5.2f\n",i,k,OBS[i],OBS[k],(W[i]/sumW),(W[k]/sumW),v);	
		}
	}

	// Computation of the oi, gi, Reli_i and CRPSpot_i from the ai and bi (Eq 30, 31, 33, 36 and 37)	
	for(j=0;j<ncol+1;j++){
		// Probability
		pj = (double)j/(double)ncol;

		// Outliers (Eq 33)
		if(j==0 && o[j]!=0.0) g[j] = b[j]/o[j];
		if(j==ncol && o[j]!=1.0) g[j] = a[j]/(1-o[j]);

		// Other cases
		if(j>0 && j<ncol){
			g[j] = a[j]+b[j];
			o[j] = b[j]/g[j];
		}
		
		r[j] = g[j]*pow(o[j]-pj,2); // Eq 36
		c[j] = g[j]*o[j]*(1-o[j]); // W[i]/sumWEq 37

		CRPSMAT[j]=pj;
		CRPSMAT[j+ncol+1]=a[j];
		CRPSMAT[j+2*(ncol+1)]=b[j];
		CRPSMAT[j+3*(ncol+1)]=g[j];
		CRPSMAT[j+4*(ncol+1)]=o[j];
		CRPSMAT[j+5*(ncol+1)]=r[j];
		CRPSMAT[j+6*(ncol+1)]=c[j];
		//printf("%d %5.2f %5.2f %5.2f %5.2f %5.2f %5.2f %5.2f\n",j,
		//	pj,a[j],b[j],g[j],o[j],r[j],c[j]);	

		CRPSVAL[0]+=a[j]*pow(pj,2)+b[j]*pow(1-pj,2); // CRPS
		if(g[j]>0){
			CRPSVAL[1]+=r[j]; // Reli
			CRPSpot+=c[j];		
		}

		// Check (Eq 34)
		v = a[j]*pow(pj,2)-g[j]*(1-o[j])*pow(pj,2);if(v<0) v= -v;
		ERRORFLAG[0]+=v/(double)(ncol+1);		
		v = b[j]*pow(1-pj,2)-g[j]*o[j]*pow(1-pj,2);if(v<0) v= -v;
		ERRORFLAG[1]+=v/(double)(ncol+1);

	}
		
	// Final computation of Resol
	CRPSVAL[2]=CRPSpot-U;
	CRPSVAL[3]=U;
	CRPSVAL[4]=CRPSpot;

	//printf("\nCRPS = %5.2f %5.2f %5.2f %5.2f\n\n",CRPSVAL[0],CRPSVAL[1],
	//		CRPSVAL[2],CRPSVAL[3]);	
}


